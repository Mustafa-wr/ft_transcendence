<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tournament</title>
    <style>
	html,
      body {
        height: 100%;
        margin: 0;
      }

	body {
		display: flex;
		align-items: center;
		justify-content: center;
		background-image: linear-gradient(to bottom right, rgb(8, 50, 104) , rgb(193, 187, 234));
		background-repeat: no-repeat;
	}
	
	.flex-container {
		display: flex;
		/* flex-wrap: wrap; */
		flex-flow: row wrap;
		justify-content: space-around;
		align-items: left;
		margin: 0;
		padding: 0;
	}
	
	.tournament-players,
	.upcoming-matches {
		text-align: left;
		width: 20%; /* Each section takes up half of the container width */
		padding: 0%; /* Add padding for spacing */
		align-items: left;
	}

	canvas {  
		outline-color: rgb(85, 24, 182);
		outline-style: solid;         
		display: block;
		margin: 20px;
		padding:30px;
		width:100%;
		max-width: 750px;
		height: 100%;
		max-height: 500px;
		/* height: auto; */
		background: #333;
	}
	/* @media (min-width: 768px) {
		.tournament-players, 
		.upcoming-matches {
			width: 100%;
			max-width: 50%; */
		/* }
	}
		*/
	#player-list {
		display: none;
	}
	
	.upcoming-matches {
		display: none;
	}
    </style>
</head>
<body>
  <div class="flex-container">
    <div class="tournament-players">
        <h2>Tournament Players List</h2>
        <ul id="player-list"></ul>
        <h2>Add a player</h2>
        <input type="text" id="player-name" placeholder="Register player">
        <button id="add-player" onclick="addPlayer()">Add player</button>
        <button id="start-tournament" onclick="startTournament()">Start Tournament</button>
    </div>
    <div class="upcoming-matches">
        <h2>Upcoming Matches</h2>
        <ul id="match-list"></ul>
    </div>
    <canvas width="750" height="500" id="game"></canvas>
  </div>
        
<script>
    
    var animationFrameID;
      var leftplayer;
      var rightplayer;
      
      // Get the canvas and context      
      const canvas = document.getElementById("game");
      const context = canvas.getContext("2d");
      const grid = 15;
      const paddleHeight = grid * 5; // 80

        var rp_count = 0;
        var lp_count = 0; 
        
            
        // Setting the maximum distance the paddles can move downwards
          const LeftmaxPaddleY = canvas.height - grid - paddleHeight ;
          const RightmaxPaddleY = canvas.height - grid - paddleHeight;
      
          var paddleSpeed = 6;
          var ballSpeed = 4;
   
          // Activate secret level
          var secret = false;
          // Number of bounces in secret mode
          var secret_count = 0;
          ballColor = "white";
    
        // Describe the left paddle
        const leftPaddle = {
          // Position it in the center
          x: grid * 2,
          y: canvas.height / 2 - paddleHeight / 2,
          width: grid,
          height: paddleHeight,
          // The paddle doesn't move anywhere at the start
          dy: 0,
        };
        // Describe the right paddle
        const rightPaddle = {
          // Position it in the center on the right side
          x: canvas.width - grid * 3,
          y: canvas.height / 2 - paddleHeight / 2,
          width: grid,
          height: paddleHeight,
          // The right paddle doesn't move anywhere initially
          dy: 0,
        };
        // Describe the ball
        const ball = {
          // It appears in the center of the field
          x: canvas.width / 2,
          y: canvas.height / 2,
          // Square, the size of a grid cell
          width: grid,
          height: grid,
          radius:( grid / 2) + 1,
          // The ball is not scored at the start, so remove the flag indicating that the ball needs to be reintroduced
          resetting: false,
          // Serve the ball to the top right corner
          dx: ballSpeed,
          dy: -ballSpeed,
        };

    function addPlayer(){
        var player_name = document.getElementById("player-name").value;
        if(player_name.trim()!= "") {
            var player_list = document.getElementById("player-list");
            var new_player = document.createElement("li");
            new_player.innerHTML = player_name;
            player_list.appendChild(new_player);
            document.getElementById("player-name").value = "";
            document.getElementById("player-list").style.display = "block";

            var players = JSON.parse(localStorage.getItem("players")) || [];
            if (players.length < 8) {
                players.push(player_name);
                localStorage.setItem("players", JSON.stringify(players));
            }
            else {
                alert("You have reached the maximum number of players allowed in a tournament");
            }
        }
        else {
            alert("Please enter a player name");
            }
    }

    function startTournament(){
        var players = JSON.parse(localStorage.getItem("players")) || [];
        if (players.length < 2){
            alert("You need at least 2 players to start a tournament");
        }
        else {
            players = players.sort(() => Math.random() - 0.5);
            localStorage.setItem("players" , JSON.stringify(players))
            var matches = [];
            for(let i = 0; i < players.length; i += 2){
                let player1 = players[i];
                let player2 = players[i + 1] || "";
                matches.push(player1 + " vs " + player2);
            }
            alert("tornnament starts now !! ");
            alert(matches[0]);
            var elements = document.querySelectorAll(".tournament-players");
            elements.forEach(function(element){
                element.style.display = "none";
            });
            var match_list = document.getElementById("match-list")
            matches.forEach(function(match){
                var new_match = document.createElement("li");
                new_match.innerHTML = match;
                match_list.appendChild(new_match);
            });
            if (matches.length > 0){
                var match_display = document.querySelectorAll(".upcoming-matches");
                match_display.forEach(function(element){
                    element.style.display = "block" ;
                });
            }
            leftplayer = players[0];
            rightplayer = players[1];
            function loop() {
        // Clear the game field
        
        if (rp_count == 3 || lp_count == 3) {
            cancelAnimationFrame(animationFrameID);
            if(rp_count == 3){            
              winner = rightplayer;
              loser = leftplayer;
              winner_score = rp_count;
              loser_score = lp_count;
            }
            else{
              winner = leftplayer;
              loser = rightplayer;
              winner_score = lp_count;
              loser_score = rp_count;
            }
            
            // gameOver();           
            alert("Game Over." + winner + " Wins!\n" + loser + " Scores: " + loser_score + "\n" +  winner +" Scores: " + winner_score);
            players.shift();
            players.shift();
            players.push(winner);
            if (players.length == 1){
              alert("Tournament Over. " + winner + " Wins!");
              localStorage.removeItem("players");
            }
            else{
              alert("Next Match: " + players[0] + " vs " + players[1] );
              rp_count  = 0;
              lp_count = 0;
              leftplayer = players[0];
              rightplayer = players[1];
              animationFrameID = requestAnimationFrame(loop);
            }
          }
        else
          animationFrameID = requestAnimationFrame(loop);

        context.clearRect(0, 0, canvas.width, canvas.height); // clear canvas
        // If the paddles were moving somewhere on the previous step, let them continue moving
        leftPaddle.y += leftPaddle.dy;
        rightPaddle.y += rightPaddle.dy;

        // check paddles stay witin the boundary
        boundary_check(leftPaddle, grid, LeftmaxPaddleY);
        boundary_check(rightPaddle, grid, RightmaxPaddleY);
             
        // Draw the paddles
        context.fillStyle = "white";
        context.fillRect(
          leftPaddle.x,
          leftPaddle.y,
          leftPaddle.width,
          leftPaddle.height
        );
        context.fillRect(
          rightPaddle.x,
          rightPaddle.y,
          rightPaddle.width,
          rightPaddle.height
        );
          // If the ball was moving somewhere on the previous step, let it continue moving
        ball.x += ball.dx;
        ball.y += ball.dy;

        //check for wall hits
        if (ball.y < grid) {
          ball.y = grid;
          ball.dy *= -1;
        }
        else if (ball.y + grid > canvas.height - grid) {
          ball.y = canvas.height - grid * 2;
          ball.dy *= -1;
        }

        // If the ball flew off the game field to the left or right, restart it
        if ((ball.x < 0 || ball.x > canvas.width) && !ball.resetting) {
          // Mark that the ball is restarted to avoid looping
          ball.resetting = true;
          if (ball.x < 0) {
            // If the ball flew off to the left, the right player scores
            rp_count += 1;
          }
          else {
            // If the ball flew off to the right, the left player scores
            lp_count += 1;
          }   
         
          // Give a second for players to prepare
          setTimeout(() => {
            // Ball is in play again
            ball.resetting = false;
            // Launch it again from the center
            ball.x = canvas.width / 2;
            ball.y = canvas.height / 2;
          }, 1000);
        }
        if (collides(ball, leftPaddle)) {          
          ball.dx *= -1;                            // send it in the opposite direction
          ball.x = leftPaddle.x + leftPaddle.width; // Increase the ball's coordinates by the paddle's width 
        }                                           //to prevent a new bounce from being counted
        else if (collides(ball, rightPaddle)) {
          ball.dx *= -1;
          ball.x = rightPaddle.x - rightPaddle.width;
          // If it reaches 5, activate the secret level
          if (rp_count >= 5 || lp_count >= 5) {
            secret = true;
          }
          // Here is the secret level itself
          if (secret) {
            // Increase new bounces
            secret_count += 1;
            // If this number is divisible by 3 without a remainder...
            if (secret_count % 3 == 0) {
              // Increase the ball speed by one
              if (ball.dx > 0) {
                ball.dx += 1;
              } else {
                ball.dx -= 1;
              }
              if (ball.dy > 0) {
                ball.dy += 1;
              } else {
                ball.dy -= 1;
              }
              // Color the ball randomly
              ballColor =
                "#" +
                (Math.random().toString(16) + "000000")
                  .substring(2, 8)
                  .toUpperCase();
            }
          }
        }
        // Draw the ball in the appropriate color
        context.fillStyle = ballColor;
        context.beginPath();
        context.arc(ball.x, ball.y, ball.radius, 0, 2 * Math.PI);
        context.fill();
        // Draw the walls
        context.fillStyle = "white";
        context.fillRect(0, 0, canvas.width, grid);
        context.fillRect(0, canvas.height - grid, canvas.width, canvas.height);
        // Draw the grid in the middle
        for (let i = grid; i < canvas.height - grid; i += grid * 2) {
          context.fillRect(canvas.width / 2 - grid / 2, i, grid, grid);
        }
        // Monitor key presses
        document.addEventListener("keydown", function (e) {
          // If the up arrow key is pressed,
          switch (e.which) {
            case 87: // W key move the left paddle up
              leftPaddle.dy = -paddleSpeed;
              break;
            case 83: // S key move the left paddle down
              leftPaddle.dy = paddleSpeed;
              break;
            case 38: // up arrow move the right paddle up
             rightPaddle.dy = -paddleSpeed;
              break;
            case 40: // down arrow move the right paddle down
              rightPaddle.dy = paddleSpeed;
              break;
          }
        });

        // Now, watch for when someone releases a key to stop the paddle's movement
        document.addEventListener("keyup", function (e) {         
          if (e.which === 38 || e.which === 40) { // If it's the up or down arrow key,stop the right paddle
            rightPaddle.dy = 0;
          }
          if (e.which === 87 || e.which === 83) { //if its 'W' or 'S' keys, stop the left paddle
            leftPaddle.dy = 0;
          }
        });

        // Text color, size and font
        context.fillStyle = "white"; 
        context.font = "30pt Arial";

        // Display player scores
        context.fillText( leftplayer + ": " + lp_count, 50, 650);
        context.fillText(rightplayer + " : " + rp_count, 700, 650);
      }
            animationFrameID = requestAnimationFrame(loop);
            // localStorage.removeItem("players");
        }
    }

    // Check whether two objects with known coordinates intersect or not
        // More details here: https://developer.mozilla.org/en-US/docs/Games/Techniques/2D_collision_detection
        function collides(obj1, obj2) {
          return (
            obj1.x < obj2.x + obj2.width &&
            obj1.x + obj1.width > obj2.x &&
            obj1.y < obj2.y + obj2.height &&
            obj1.y + obj1.height > obj2.y
          );
        }

        function boundary_check(paddle, top, bottom) {
          if (paddle.y < top) {
            paddle.y = top;
          } else if (paddle.y > bottom) {
            paddle.y = bottom;
          }      
        }


</script>
</body>
</html>